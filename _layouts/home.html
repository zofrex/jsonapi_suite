---
layout: default
---

<div class="home">
  <a class="btn btn-primary skip-intro" href="{{site.github.url}}/quickstart">Skip Intro &raquo;</a>

  <div class="start p">
    <a class="l bold mag" href="{{site.github.url}}/ruby">JSONAPI SUITE</a>
    is a collection of
    <span class="s bold">ruby libraries</span>
    that facilitate the
    <a href="http://jsonapi.org" class="s">jsonapi.org</a>
    specification.
  </div>

  <div class="p unfamiliar">
    If you're
    <span class="s">unfamiliar</span>
    with
    <span class="bold">JSONAPI</span>,
    think

    <div class="yehuda quote">"RESTful GraphQL created by Yehuda Katz"</div>
  </div>

  <div class="p">
    Here's a simple Suite app:
  </div>

<span class="sample">
  {% highlight ruby %}
# controllers/posts_controller.rb
class PostsController
  jsonapi resource: PostResource

  def index
    posts = Post.all
    render_jsonapi(posts)
  end
end
  {% endhighlight %}

  {% highlight ruby %}
# resources/post_resource.rb
class PostResource
  type :posts
  model Post

  allow_filter :title
  allow_stat total: [:count]
end
  {% endhighlight %}

  {% highlight ruby %}
# serializers/serializable_posts.rb
class SerializablePosts
  type :posts

  attribute :title
  attribute :created_at
  attribute :updated_at
end
  {% endhighlight %}
  </span>

  <div class="p">
    This API now supports
    <a class="s bold" href="http://jsonapi.org/format/#fetching-sparse-fieldsets">Sparse Fieldsets</a>,
    <a class="s bold" href="http://jsonapi.org/format/#fetching-sorting">Sorting</a>,
    <a class="s bold" href="http://jsonapi.org/format/#fetching-pagination">Pagination</a>,
    <span class="s bold">statistics</span>, and
    <a class="s bold" href="http://jsonapi.org/format/#fetching-filtering">Filtering</a>.

    Though we're using
    <code class="highlighter-rouge">ActiveRecord</code>
    in these examples, the same patterns
    apply to
    <span class="m bold underline">ANY ORM or DATASTORE</span>
    including
    <span class="s bold">HTTP calls</span>.
    Blend SQL and NoSQL in a
    <span class="s bold">single</span>
    request.
  </div>

  <div class="p">
    Let's access the API using our
    <a class="s bold" href="https://jsonapi-suite.github.io/jsonapi_suite/js/home">Javascript Client</a>,
    which you can think of as
    <div class="quote">
      "<code class="highlighter-rouge">ActiveRecord</code> in the browser"
    </div>
  </div>

  <span class="sample">
  {% highlight typescript %}
await Post
  .where({ title: "Hello!" })
  .order({ created_at: "desc" })
  .per(10).page(2)
  .stats({ total: "count" })
  .fields(["title", "byline"])
  {% endhighlight %}
  </span>

  {% comment %}customize filter, no magic, complete control{% endcomment %}
  {% comment %}maybe invert with the any data store bit{% endcomment %}
  {% comment %}then associations, swagger, backwards-compat{% endcomment %}
  {% comment %}microservices{% endcomment %}
  {% comment %}testing√ü{% endcomment %}

  <div class="p">
    <span class="m bold">Associations</span> are simple and customizable:

    <span class="sample">
  {% highlight ruby %}
# app/resources/post_resource.rb
has_many :comments,
  scope: -> { Comment.all },
  resource: CommentResource,
  foreign_key: :post_id
  {% endhighlight %}

  {% highlight typescript %}
// In your JS app
Post.includes("comments")
  {% endhighlight %}
    </span>
  </div>

  <div class="p">
    Associations are
    <span class="bold">deep queryable</span>. In other words,
    you could fetch the Post and only its
    <code class="highlighter-rouge">active</code> comments,
    sorted by
    <code class="highlighter-rouge">created_at</code> descending.
    This applies to your
    <span class="s mag bold">entire graph of data.</span>
    The server-side code would be nothing more than:
  </div>

  <span class="sample">
  {% highlight ruby %}
allow_filter :active
  {% endhighlight %}
  </span>

  <div class="p">
    At this point, You may be thinking:

    <div>
      <span class="lg italic quote">
        "Is this just a bunch of incomprehensible ruby magic
      </span>
      <span class="quote">üò¨
      <span class="lg italic quote">
      ?"
      </span>
    </div>

    <div>
      <span class="m bold underline">No.</span>
    </div>

    We're simply parsing the request, removing boilerplate, and supplying
    <span class="s bold mag">sensible defaults</span> because we believe in
    <span class="s bold">convention over configuration</span>.
  </div>

  <div class="p">
    Let's make our filter a prefix query:
  </div>

  <span class="sample s">
  {% highlight ruby %}
allow_filter :title_prefix do |scope, value|
  scope.where(["title LIKE ?", "#{value}%"])
end
  {% endhighlight %}
  </span>

  <div class="p">
    From filtering to pagination, these are all just
    <span class="s mag">customizable lambdas</span>.
    You have
    <span class="m bold">complete control</span>
    of the query.
  </div>

  <div class="p">
    Just as you can
    <span class="m bold mag">Query</span>
    the full graph of data, you can also
    <span class="m bold mag">Persist</span>
    the full graph of data in a
    <span class="underline">single request</span>:
  </div>

  <span class="sample s">
  {% highlight typescript %}
post = new Post({ title: "JSONAPI Rocks!" })
comment = new Comment({ body: "I agree!" })
post.comments.push(comment)
post.save({ with: "comments" })
  {% endhighlight %}
  </span>

  <div class="p">
    All of this is easily validated with
    <span class="m bold">end-to-end</span>
    <span class="m bold">integration test patterns</span>
    that ensure
    <span class="s mag">backwards-compatibility</span>:
  </div>

  <span class="sample s">
  {% highlight ruby %}
let(:post1) { create(:post, title: "Hello") }
let(:post2) { create(:post, title: "Hiya") }

it "filters correctly" do
  jsonapi_get '/api/v1/posts', params: {
    filter: { title_prefix: 'He' }
  }
  expect(json_ids(true)).to eq([post1.id])
  assert_payload(:post, post1, json_items[0])
end
  {% endhighlight %}
  </span>

  <div class="p">
    ...and
    <span class="mag s bold">automatically documented</span>
    in <span class="bold">Swagger</span>:
  </div>

  <div class="p">
    <img width="100%" src="https://user-images.githubusercontent.com/55264/28526490-af7ce5a8-7055-11e7-88bf-1ce5ead32dd7.png">
  </div>

  <div class="p">
    There's
    <span class="m bold">so much more</span>
    to talk about. To get your feet wet, check out
    our
    <a class="m bold" href="{{site.github.url}}/quickstart">Quickstart</a>,
    or step-by-step
    <a class="m bold" href="{{site.github.url}}/tutorial">Tutorial</a>.
    We also have
    <span class="m bold">comprehensive documentation</span>
    on the
    <a class="m bold" href="{{site.github.url}}/ruby">Server</a>
    and on the
    <a class="m bold" href="{{site.github.url}}/js/home">Client</a>.
    Join our
    <a target="_blank" class="m bold" href="https://join.slack.com/t/jsonapi-suite/shared_invite/enQtMjkyMTA3MDgxNTQzLWVkMDM3NTlmNTIwODY2YWFkMGNiNzUzZGMzOTY3YmNmZjBhYzIyZWZlZTk4YmI1YTI0Y2M0OTZmZGYwN2QxZjg">Slack Chat</a>
    to ask questions or say hi - we'd
    love to meet you and hear what you think ‚ù§Ô∏è
  </div>
</div>
